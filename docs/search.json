[{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Stefan Wager. Maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Athey S, Imbens G, Wager S (2023). balanceHD: Approximately balanced estimation average treatment effects high dimensions.. R package version 1.0.","code":"@Manual{,   title = {balanceHD: Approximately balanced estimation of average treatment effects in high dimensions.},   author = {Susan Athey and Guido Imbens and Stefan Wager},   year = {2023},   note = {R package version 1.0}, }"},{"path":"/index.html","id":"balancehd","dir":"","previous_headings":"","what":"Approximately balanced estimation of average treatment effects in high dimensions.","title":"Approximately balanced estimation of average treatment effects in high dimensions.","text":"Estimation average treatment effects high dimensions via approximate residual balancing, proposed Athey et al. (2016). Fork Stefan Wager’s original package convenience functions + continued development using alternative nuisance function estimators. install package R, run following commands: package currently works three optimizers: mosek, pogs, quadprog. Mosek commercial interior point solver, pogs first-order optimizer, based ADMM, quadprog standard R optimization library. general, achieved best performance mosek, recommend trying optimizers order listed . found pogs somewhat slower mosek problems tried. (Note offer two solution strategies based pogs: pogs pogs.dual. usually recommend former, except p much larger n.) Finally, quadprog performors well small problems, can much slower larger problems. terms availability, optimizer quadprog easiest access, available directly CRAN. Pogs needs installed separately, still free. install pogs, simply install one pre-compiled binaries available project repository; see page furhter instructions. Finally, mosek commercial solver; however, academic licenses available free. One mosek installed, call using R package Rmosek. Example usage:","code":"library(devtools) install_github(\"apoorvalal/balanceHD\") set.seed(42) library(balanceHD)  n = 400; p = 1000 tau = 7 nclust = 10 beta = 2 / (1:p) / sqrt(sum(1 / (1:p)^2)) # cluster assingment clust.ptreat = rep(c(0.1, 0.9), nclust / 2) cluster.center = 0.5 * matrix(rnorm(nclust * p), nclust, p) cluster = sample.int(nclust, n, replace = TRUE) X = cluster.center[cluster, ] + matrix(rnorm(n * p), n, p)  W = rbinom(n, 1, clust.ptreat[cluster]) Y = X %*% beta + rnorm(n, 0, 1) + tau * W  # bad naive.ate(X, Y, W)  ## [1] 6.339"},{"path":"/index.html","id":"main-function","dir":"","previous_headings":"","what":"main function","title":"Approximately balanced estimation of average treatment effects in high dimensions.","text":"","code":"library(tictoc)  ##  ## Attaching package: 'tictoc'  ## The following object is masked from 'package:data.table': ##  ##     shift  tic() tau.hat = residualBalance.ate(X, Y, W, estimate.se = TRUE, optimizer = \"mosek\") toc()  ## 1.355 sec elapsed  print(paste(\"true tau:\", tau))  ## [1] \"true tau: 7\"  print(paste(\"point estimate:\", round(tau.hat[1], 2)))  ## [1] \"point estimate: 6.84\"  print(paste0(   \"95% CI for tau: (\", round(tau.hat[1] - 1.96 * tau.hat[2], 2),   \", \", round(tau.hat[1] + 1.96 * tau.hat[2], 2), \")\" ))  ## [1] \"95% CI for tau: (6.49, 7.2)\""},{"path":"/index.html","id":"alternate-optimizers","dir":"","previous_headings":"","what":"alternate optimizers","title":"Approximately balanced estimation of average treatment effects in high dimensions.","text":"POGS good big problems takes setup linux.","code":"tic() tau.hat = residualBalance.ate(X, Y, W, estimate.se = TRUE, optimizer = \"quadprog\")  ## Warning in approx.balance(XW, balance.target, zeta = zeta, ## allow.negative.weights = allow.negative.weights, : bound.gamma = TRUE not ## implemented for this optimizer  ## Warning in approx.balance(XW, balance.target, zeta = zeta, ## allow.negative.weights = allow.negative.weights, : bound.gamma = TRUE not ## implemented for this optimizer  toc()  ## 0.499 sec elapsed  print(paste(\"true tau:\", tau))  ## [1] \"true tau: 7\"  print(paste(\"point estimate:\", round(tau.hat[1], 2)))  ## [1] \"point estimate: 6.85\"  print(paste0(   \"95% CI for tau: (\", round(tau.hat[1] - 1.96 * tau.hat[2], 2),   \", \", round(tau.hat[1] + 1.96 * tau.hat[2], 2), \")\" ))  ## [1] \"95% CI for tau: (6.5, 7.2)\" tic() tau.hat = residualBalance.ate(X, Y, W, estimate.se = TRUE, optimizer = \"pogs\") toc()  ## 0.517 sec elapsed  print(paste(\"true tau:\", tau))  ## [1] \"true tau: 7\"  print(paste(\"point estimate:\", round(tau.hat[1], 2)))  ## [1] \"point estimate: 6.85\"  print(paste0(   \"95% CI for tau: (\", round(tau.hat[1] - 1.96 * tau.hat[2], 2),   \", \", round(tau.hat[1] + 1.96 * tau.hat[2], 2), \")\" ))  ## [1] \"95% CI for tau: (6.5, 7.2)\""},{"path":[]},{"path":"/index.html","id":"aipw","dir":"","previous_headings":"Standard methods","what":"AIPW","title":"Approximately balanced estimation of average treatment effects in high dimensions.","text":"Default elastic net outcome model pscore. use grf pscore","code":"ipw.ate(X, Y, W, estimate.se = TRUE)  ## [1] 6.8227 0.1432 ipw.ate(X, Y, W, prop.method = \"randomforest\", estimate.se = TRUE)  ## [1] 6.9013 0.1283"},{"path":"/index.html","id":"ipw","dir":"","previous_headings":"Standard methods","what":"IPW","title":"Approximately balanced estimation of average treatment effects in high dimensions.","text":"","code":"ipw.ate(X, Y, W, fit.method = \"none\", estimate.se = TRUE)  ## [1] 6.3583 0.2557"},{"path":"/index.html","id":"om","dir":"","previous_headings":"Standard methods","what":"OM","title":"Approximately balanced estimation of average treatment effects in high dimensions.","text":"","code":"elnet.ate(X, Y, W, estimate.se = TRUE)  ## [1] 6.895 0.134"},{"path":"/index.html","id":"double-lasso","dir":"","previous_headings":"Standard methods","what":"double lasso","title":"Approximately balanced estimation of average treatment effects in high dimensions.","text":"","code":"twostep.lasso.ate(X, Y, W, estimate.se = TRUE)  ##  [1]   1   2   3   4   5   9  10  16 108 242 284 319 389 509 742 767 808 865 925 ## [20]  42  82 106 131 149 160 187 231 250 262 278 286 309 316 353 357 359 375 383 ## [39] 394 395 404 428 456 458 493 496 500 542 545 572 665 705 729 734 739 785 799 ## [58] 807 814 818 820 892 895 904 911 937 948 958 961 981 ##  [1]   1   2   3   4   5   9  10  16 108 242 284 319 389 509 742 767 808 865 925 ## [20]  42  82 106 131 149 160 187 231 250 262 278 286 309 316 353 357 359 375 383 ## [39] 394 395 404 428 456 458 493 496 500 542 545 572 665 705 729 734 739 785 799 ## [58] 807 814 818 820 892 895 904 911 937 948 958 961 981  ##      1         ## 6.6556 0.1765"},{"path":"/index.html","id":"references","dir":"","previous_headings":"Standard methods > double lasso","what":"References","title":"Approximately balanced estimation of average treatment effects in high dimensions.","text":"Susan Athey, Guido Imbens, Stefan Wager. Approximate Residual Balancing: De-Biased Inference Average Treatment Effects High Dimensions. 2016. [arxiv]","code":""},{"path":"/reference/approx.balance.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute approximately balancing weights — approx.balance","title":"Compute approximately balancing weights — approx.balance","text":"Returns minimizer :   (1 - zeta) ||gamma||^2 + zeta ||M'gamma - balance.target||_infty^2 (*)","code":""},{"path":"/reference/approx.balance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute approximately balancing weights — approx.balance","text":"","code":"approx.balance(   M,   balance.target,   zeta = 0.5,   allow.negative.weights = FALSE,   optimizer = c(\"mosek\", \"pogs\", \"pogs.dual\", \"quadprog\"),   bound.gamma = FALSE,   gamma.max = 1/nrow(M)^(2/3),   verbose = FALSE )"},{"path":"/reference/approx.balance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute approximately balancing weights — approx.balance","text":"M feature matrix, see (*) balance.target target solution, see (*) zeta tuning parameter, see (*) allow.negative.weights gammas allowed negative? optimizer optimizer use? Mosek commercial solver, free academic licenses available. Needs installed separately. Pogs runs ADMM may useful large problems, must installed separately. Quadprog default R solver. bound.gamma whether upper bound gamma imposed gamma.max specific upper bound gamma (ignored bound.gamma = FALSE) verbose whether optimizer print progress information","code":""},{"path":"/reference/approx.balance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute approximately balancing weights — approx.balance","text":"gamma, minimizer (*)","code":""},{"path":"/reference/elnet.ate.html","id":null,"dir":"Reference","previous_headings":"","what":"Elastic net correction for confounding variables — elnet.ate","title":"Elastic net correction for confounding variables — elnet.ate","text":"Elastic net correction confounding variables","code":""},{"path":"/reference/elnet.ate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Elastic net correction for confounding variables — elnet.ate","text":"","code":"elnet.ate(X, Y, W, target.pop = c(0, 1), alpha = 0.9, estimate.se = FALSE)"},{"path":"/reference/elnet.ate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Elastic net correction for confounding variables — elnet.ate","text":"X input features Y observed responses W treatment/control assignment, coded 0/1 target.pop population treatment effect estimated ? (0, 1): average treatment effect everyone 0: average treatment effect controls 1: average treatment effect treated","code":""},{"path":"/reference/elnet.ate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Elastic net correction for confounding variables — elnet.ate","text":"ATE estimate","code":""},{"path":"/reference/ipw.ate.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate ATE via inverse propensity weighting — ipw.ate","title":"Estimate ATE via inverse propensity weighting — ipw.ate","text":"Estimate ATE via inverse propensity weighting","code":""},{"path":"/reference/ipw.ate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate ATE via inverse propensity weighting — ipw.ate","text":"","code":"ipw.ate(   X,   Y,   W,   target.pop = c(0, 1),   eps.threshold = 1/20,   fit.method = c(\"elnet\", \"none\"),   alpha.fit = 0.9,   prop.method = c(\"elnet\", \"randomforest\"),   alpha.prop = 0.5,   prop.weighted.fit = FALSE,   targeting.method = c(\"AIPW\", \"TMLE\"),   estimate.se = FALSE )"},{"path":"/reference/ipw.ate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate ATE via inverse propensity weighting — ipw.ate","text":"X input features Y observed responses W treatment/control assignment, coded 0/1 target.pop population treatment effect estimated ? (0, 1): average treatment effect everyone 0: average treatment effect controls 1: average treatment effect treated eps.threshold cap estimated propensities fit.method method used fit mu(x, w) = E[Y | X = x, W = w] alpha.fit tuning paramter glmnet mu model prop.method method used fit e(x) = P[W = 1 | X] alpha.prop tuning paramter glmnet propsenity model prop.weighted.fit whether propensity weights used sample weights outcome fit targeting.method combine outcome propensity model fits.","code":""},{"path":"/reference/ipw.ate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate ATE via inverse propensity weighting — ipw.ate","text":"ATE estimate","code":""},{"path":"/reference/naive.ate.html","id":null,"dir":"Reference","previous_headings":"","what":"No correction for confounding variables (difference in means) — naive.ate","title":"No correction for confounding variables (difference in means) — naive.ate","text":"correction confounding variables (difference means)","code":""},{"path":"/reference/naive.ate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"No correction for confounding variables (difference in means) — naive.ate","text":"","code":"naive.ate(X, Y, W, estimate.se = FALSE)"},{"path":"/reference/naive.ate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"No correction for confounding variables (difference in means) — naive.ate","text":"X input features Y observed responses W treatment/control assignment, coded 0/1","code":""},{"path":"/reference/naive.ate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"No correction for confounding variables (difference in means) — naive.ate","text":"ATE estimate","code":""},{"path":"/reference/residualBalance.ate.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate ATE via approximate residual balancing — residualBalance.ate","title":"Estimate ATE via approximate residual balancing — residualBalance.ate","text":"Estimate ATE via approximate residual balancing","code":""},{"path":"/reference/residualBalance.ate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate ATE via approximate residual balancing — residualBalance.ate","text":"","code":"residualBalance.ate(   X,   Y,   W,   target.pop = c(0, 1),   allow.negative.weights = FALSE,   zeta = 0.5,   fit.method = c(\"elnet\", \"none\"),   alpha = 0.9,   scale.X = TRUE,   estimate.se = FALSE,   optimizer = c(\"mosek\", \"pogs\", \"pogs.dual\", \"quadprog\"),   bound.gamma = TRUE,   verbose = FALSE )"},{"path":"/reference/residualBalance.ate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate ATE via approximate residual balancing — residualBalance.ate","text":"X input features Y observed responses W treatment/control assignment, coded 0/1 target.pop population treatment effect estimated ? (0, 1): average treatment effect everyone 0: average treatment effect controls 1: average treatment effect treated allow.negative.weights whether negative gammas allowed balancing zeta tuning parameter selecting approximately balancing weights fit.method method used fit mu(x, w) = E[Y | X = x, W = w] alpha tuning paramter glmnet scale.X whether non-binary features noramlized estimate.se whether return estimate standard error optimizer optimizer use approximate balancing bound.gamma Whether upper bound gamma imposed. required guarantee asymptotic normality, increases computational cost. verbose whether optimizer print progress information","code":""},{"path":"/reference/residualBalance.ate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate ATE via approximate residual balancing — residualBalance.ate","text":"ATE estimate, along (optional) standard error estimate","code":""},{"path":"/reference/residualBalance.mean.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate mean outcome at balance.target via residual balancing — residualBalance.mean","title":"Estimate mean outcome at balance.target via residual balancing — residualBalance.mean","text":"Estimate mean outcome balance.target via residual balancing","code":""},{"path":"/reference/residualBalance.mean.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate mean outcome at balance.target via residual balancing — residualBalance.mean","text":"","code":"residualBalance.mean(   XW,   YW,   balance.target,   allow.negative.weights = FALSE,   zeta,   fit.method = c(\"elnet\", \"none\"),   alpha,   optimizer = c(\"mosek\", \"pogs\", \"pogs.dual\", \"quadprog\"),   bound.gamma = TRUE,   verbose = FALSE )"},{"path":"/reference/residualBalance.mean.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate mean outcome at balance.target via residual balancing — residualBalance.mean","text":"XW input features sub-population interest YW observed responses sub-population interest balance.target desired center dataset allow.negative.weights whether negative gammas allowed balancing zeta tuning parameter selecting approximately balancing weights fit.method method used fit mu(x) = E[YW | XW = x] alpha tuning paramter glmnet optimizer optimizer use approximate balancing bound.gamma whether upper bound gamma imposed verbose whether optimizer print progress information","code":""},{"path":"/reference/residualBalance.mean.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate mean outcome at balance.target via residual balancing — residualBalance.mean","text":"Estimate E[YW | XW = balance.target], along variance estimate","code":""},{"path":"/reference/twostep.lasso.ate.html","id":null,"dir":"Reference","previous_headings":"","what":"Refit lasso correction for confounding variables — twostep.lasso.ate","title":"Refit lasso correction for confounding variables — twostep.lasso.ate","text":"Refit lasso correction confounding variables","code":""},{"path":"/reference/twostep.lasso.ate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Refit lasso correction for confounding variables — twostep.lasso.ate","text":"","code":"twostep.lasso.ate(   X,   Y,   W,   target.pop = c(0, 1),   fit.propensity = TRUE,   estimate.se = FALSE )"},{"path":"/reference/twostep.lasso.ate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Refit lasso correction for confounding variables — twostep.lasso.ate","text":"X input features Y observed responses W treatment/control assignment, coded 0/1 target.pop population treatment effect estimated ? (0, 1): average treatment effect everyone 0: average treatment effect controls 1: average treatment effect treated fit.propensity propensity model used variable selection?","code":""},{"path":"/reference/twostep.lasso.ate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Refit lasso correction for confounding variables — twostep.lasso.ate","text":"ATE estimate","code":""}]
